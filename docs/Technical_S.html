<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RCI Message Board: Server Application Technical Specs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RCI Message Board
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">https://github.com/Jguer/RCI-Message-Board</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Server Application Technical Specs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When the application is called in the command line it can have various arguments:<br />
Non-Optional<br />
</p><blockquote class="doxtable">
<p>n [name] -&gt; Intended name for the server<br />
j [ip address] -&gt; IP address for the server. Must be the ip of the machine<br />
u [UDP port] -&gt; Port for udp incoming connections. Must be free port.<br />
t [TCP port] -&gt; Port for tcp incoming connections. Must be free port.<br />
</p>
</blockquote>
<p>Optional<br />
</p><blockquote class="doxtable">
<p>i [ip address] -&gt; IP address of the identity server.<br />
 Default: tejo.tecnico.ulisboa.pt<br />
p [port of address] -&gt; Port of the identity server on that IP address.<br />
 Default: 59000<br />
m [max. messages] -&gt; Maximum number of messages that the server can save.<br />
 Default: 200<br />
r [register interval] -&gt; Time (in seconds) between registers to the id server.<br />
 Default:10s<br />
</p>
</blockquote>
<h1>Program work flow (#server_workflow) </h1>
<ul>
<li>Parse terminal arguments</li>
<li>Get id server address to check if it exists:</li>
<li>Initiates the program fundamental variables<ul>
<li>Initialize sockets (<a class="el" href="Technical_S.html#file_descriptors_server">File descriptors</a>)</li>
<li>Initializes the timer implementation</li>
</ul>
</li>
<li>Enters a interactive loop where the program will run until it finds an error or is told to exit.<ul>
<li>Sends all the file descriptors (fd) to a set, the set will be watched and each fd will be handled only when its ready (The communications only start after the user asks to join, and returns successful).</li>
<li>The program will wait in the select function until one of the <a class="el" href="Technical_S.html#file_descriptors_server">file descriptors</a> is ready to be read.</li>
<li>The registration to id server is refreshed, if the time as elapsed.</li>
<li>If a server tries to connect it is accepted and saved in a list. See <a class="el" href="Technical_S.html#incom_tcp_req">incoming request to connect</a></li>
<li>If an incoming udp message is received the incoming message is handled. See <a class="el" href="Technical_S.html#udp_handle_server">udp handling</a>.</li>
<li>If the user sends input to console the command must be interpreted. See <a class="el" href="Technical_S.html#user_input_server">user input handling</a>.<ul>
<li>User join command is where this program starts the main routines.</li>
<li>Join sends the first register to the id server. Gets the already present servers and verifies if this server is registered. Then proceeds to open communications to the already joined servers, where it ask for the messages to just one server (The first that answers the request).</li>
<li>The other options just print the current info of the messages and connected servers. Or exit.</li>
</ul>
</li>
<li>If theres an incoming tcp message from a already connected server it is treated accordingly. See <a class="el" href="Technical_S.html#tcp_handle_server">tcp handling</a>.</li>
<li>Reprints the prompt if its necessary.</li>
<li>Loop restarts.</li>
</ul>
</li>
<li>Free all allocated memory and exit.</li>
</ul>
<h1><a class="anchor" id="file_descriptors_server"></a>
File descriptors</h1>
<ul>
<li>STDIN: This file descriptor is used to read from the user and is only ready when the user send input to the terminal.</li>
<li>UDP:<ul>
<li>Global fd: This socket is binded to a port in the system, so that the clients can communicate to a well known port and the select function can process the file descriptor, it is used just to receive and send information to clients.</li>
<li>Outgoing fd: This socket is only used to ask for servers from the identity server and register.</li>
</ul>
</li>
<li>TIMER: (Library: timer_fd.h) This timer is implemented via a file descriptor. When the timer is triggered the file descriptor is set as ready to read.</li>
<li>TCP:<ul>
<li>Listen fd: Listen_fd receives incoming connections who latter will be answered and communicate via another file descriptor (server_fd)</li>
<li>Server fd: There can be many file descriptors of this in the program. Any server who is connected tho this server will have it's own file descriptor, who is saved in their own server struct.</li>
<li>The file descriptors are handled with the select() function who blocks until one of the file descriptors signals that it is ready to read. This function control the work flow of the program.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="incom_tcp_req"></a>
Incoming requests to connect </h1>
<p>When a server tries to connect it is put on a queue of 5 servers capacity.<br />
This routine accepts the connection, and saves that server info on a list dedicated to server struct items. This items contain the server name, ip address, tcp port and the corresponding file descriptor. Theres a udp port slot, who is unused. This structure is shared between client and server.</p>
<p>Every incoming server has is name set to Inbound Server.</p>
<h1><a class="anchor" id="udp_handle_server"></a>
UDP incoming messages treatment </h1>
<p>The server is projected to only be able to receive two type of message from the clients. The messages can have one of two headers: <code>'PUBLISH message'</code> or <code>'GET_MESSAGES n'</code>.</p>
<p>First thing to do is allocate some space in memory to save our incoming communication, being sent via UDP, the message arrives all at once and the buffer needs to have size for the entire communication.<br />
The size is the size of 'PUBLISH' plus the size of the whole message (140 char. max). All that is received with more size than the size who was allocated is lost.</p>
<p>After receiving the information, it is saved in a message struct, in the case of 'PUBLISH' being the header, the logical clock is set to the next logical clock. (eg. if LastMessageLC == 1 so NewMessageLC = 2)</p>
<p>If 'GET_MESSAGES n' is received, the last n messages are fetched from the matrix and sent to the client who made the request. If n is bigger than the number of messages present, only the present messages are sent to the user.</p>
<h1><a class="anchor" id="user_input_server"></a>
User input interpretation </h1>
<p>The commands that the user can input are: These are not case-sensitive and there are numeric shortcuts. </p><table class="doxtable">
<tr>
<th align="left">Command </th><th align="center">Shortcut  </th></tr>
<tr>
<td align="left">join </td><td align="center">1 </td></tr>
<tr>
<td align="left">show_servers </td><td align="center">2 </td></tr>
<tr>
<td align="left">show_messages </td><td align="center">3 </td></tr>
<tr>
<td align="left">exit </td><td align="center">9 </td></tr>
</table>
<p>Join command starts the communications to other servers and enables client communications.<br />
The show_servers command prints the list currently being used to select the server at work.<br />
The show_messages command prints the matrix currently being used to save messages.<br />
Exit command breaks out of the loop.</p>
<h1><a class="anchor" id="tcp_handle_server"></a>
TCP handling </h1>
<p>Server to server communications are based in two types of headers: <code>'SMESSAGES\n(message\n)\n'</code> or <code>'SGET_MESSAGES\n'</code>.</p>
<p>The parsing of information is made at the rate of the incoming bytes from the recv command, and split in '<br />
' sequences.</p>
<p>The former is interpreted as a command to save the messages. The later requests all the messages that this server has.</p>
<p>After receiving the information, it is saved in a message struct, in the case of 'SMESSAGES' being the header, the logical clock is set to the next logical clock of the MAX between LastMessageLC and IncomingMessageLC. (eg. if LastMessageLC == 20 and IncomingMessageLC == 5 so NewMessageLC = 21)</p>
<p>If 'SGET_MESSAGES' is received, the messages are fetched from the matrix and sent to the server who made the request. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
